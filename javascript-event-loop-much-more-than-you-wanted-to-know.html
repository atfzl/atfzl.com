<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>JavaScript Event Loop: Much more than you wanted to know - Atif Afzal</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Note: We’ll cover the event loop in context of browsers and not other runtimes like Node.js The event loop is a mechanism/algorithm/set of rules">
    <meta name="twitter:card" content="summary">
    <meta property="og:type" content="website">
    <meta name="twitter:title" property="og:title" itemprop="title name" content="JavaScript Event Loop: Much more than you wanted to know - Atif Afzal">
    <meta name="twitter:description" property="og:description" itemprop="description" content="Note: We’ll cover the event loop in context of browsers and not other runtimes like Node.js The event loop is a mechanism/algorithm/set of rules">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for Atif Afzal" href="https://atfzl.com/feed.rss">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&display=swap" rel="stylesheet" />
    <style>


/* Small caps */
.small-caps {}

/* Double quote (") marks */
.pull-double{margin-left:-.45em}
.push-double{margin-right:.45em}

/* Single quote (') marks */
.pull-single{margin-left:-.20em}
.push-single{margin-right:.20em}

/* Optical margin alignment for particular letters */
.pull-T, .pull-V, .pull-W, .pull-Y {margin-left: -0.1em}
.push-T, .push-V, .push-W, .push-Y {margin-right: 0.1em}

.pull-O, .pull-C, .pull-o, .pull-c {margin-left: -0.06em}
.push-O, .push-C, .push-o, .push-c {margin-right: 0.06em}

.pull-A {margin-left: -0.04em}
.push-A {margin-right: 0.04em}

:root {
  --main-font-family: "IBM Plex Sans", -apple-system, BlinkMacSystemFont, "avenir next", avenir, "helvetica neue", helvetica, ubuntu, roboto, noto, "segoe ui", arial, sans-serif;
}

html {
  overflow-y: scroll;
}

body {
  font: 16px var(--main-font-family);
  text-rendering: optimizeLegibility;
  /*-webkit-font-smoothing: antialiased;*/
  /*
  font-variant-ligatures: common-ligatures;
  font-feature-settings: "liga";
  -moz-font-feature-settings: “liga” on;
  */
  color: #000;
  word-wrap: break-word;
  line-height: 1.5;
  margin: 16px;
}

.clear {width: 100%;clear: both;float: none;display: block;height: 0}

.small,
.caption {font-size: 13px;font-family: var(--main-font-family);color: #999;font-weight: 500;}

.caption {
  line-height: 18px;
  display: block;
  margin: 9px auto 24px;
  max-width: 600px;
  font-style: normal;
}

/* 29.3333 / 1.2933333 */
.wide.left .caption {margin-left: 22.680412113%}
.wide.right .caption {margin-right: 22.680412113%}


.right {float: right;}
.left {float: left;}

div {
  margin: 0 auto;
  overflow: visible;
  position: relative;
}

.header {margin-top: 48px;margin-bottom: 72px}
.main {max-width: 60%;min-width: 600px;}
.container {max-width: 1000px}
.entry {margin: 72px 0 120px}
.archive-list {
  font-family: var(--main-font-family);
  margin-top: 40px;
}

/* LAYOUT */

.margin {
  position: absolute;
  box-sizing: border-box;
  width: 29.3333%;
}

.margin blockquote {margin: 3px 0;color:#232323;padding: 3px 6px;font-size: 14px;line-height:18px;border: 1px solid rgba(0,0,0,0.1);border-left:4px solid rgba(0,0,0,0.2);background: rgba(0,0,0,0.05);}
.margin blockquote p {margin: 0}

.margin img,
.column img {margin-top: 6px}

.margin p {font-style: italic;font-family: var(--main-font-family);font-size: 0.9em;margin-top: 0}
.margin h1, .margin h2, .margin h3 {margin-top:0}

.left.margin {
  left: -29.3333%;
  padding-right: 30px;
  text-align: right;
}

.right.margin {
  right: -29.3333%;
  padding-left: 30px;
}

.wide {
  width: 158.6666667%;
  margin-left: -29.3333333%;
  overflow: auto; /* collapse internal margins */
}

.wide.left, .wide.right {width: 129.3333333%;float: none;}
.wide.left {margin: 0 0 0 -29.3333333%}
.wide.right {margin: 0 -29.3333333% 0 0}

.column {
  box-sizing: border-box;
  float: left;
}

.column .caption {margin-bottom: 6px}

.column.two {
  width: 50%;
  padding-right: 12px;
}

.column.three {
  width: 33%;
  padding-right: 24px;
}

.column.two + .column.two {
  padding: 0 0 0 12px;
}

.column h1,
.column h2,
.column h3 {margin-bottom: -12px}

/* TEXT */

p, li {
  font-size: 18px;
  font-family: var(--main-font-family);
  position: relative;
  margin: 24px 0;
  line-height: 1.6;
}

h1, h2, h3, h4, h5, h6 {
  font-family: var(--main-font-family);
  font-weight: 800;
}

h1 {
  font-size: 42px;
  margin-bottom: -4px;
}

h2 {
  line-height: 1;
  font-size: 24px;
  margin: 40px 0 24px;
}

h3, h4, h5, h6 {
  line-height: 1;
  font-size: 20px;
  margin: 40px 0 20px;
}

blockquote {
  padding: 0 0 0 12px;
  color: #777
}

/*
p .small-caps,
li .small-caps {
  font-family: "Georgia Pro SC";
}*/

big {color: #000;font-size: 32px;font-family: var(--main-font-family);line-height: 48px;display: block;}

/* LINKS */

a {
  color: #004984; /* 02569B */
  text-decoration: none;
  text-shadow: .03em 0 #fff, -.03em 0 #fff, 0 .03em #fff, 0 -.03em #fff, .06em 0 #fff, -.06em 0 #fff, .09em 0 #fff, -.09em 0 #fff, .12em 0 #fff, -.12em 0 #fff, 0 0.03em #fff, 0 -.03em #fff, 0 .06em #fff, 0 -.06em #fff, 0 .08em #fff, 0 -.08em #fff;
  background-image: linear-gradient(#fff, #fff), linear-gradient(#fff, #fff), linear-gradient(#004984, #004984);
  background-size: 0 0,0 0,0.07em 0.07em;
  background-repeat: no-repeat, no-repeat, repeat-x;
  background-position: 0% 90%, 100% 90%, 0% 95%;
}

a:hover {
  color: #468CC7;
  background-image: linear-gradient(#fff, #fff), linear-gradient(#fff, #fff), linear-gradient(#5599D2, #5599D2);
}

a::selection {
  background: #b3d4fd;
  text-shadow: .03em 0 #b3d4fd, -.03em 0 #b3d4fd, 0 .03em #b3d4fd, 0 -.03em #b3d4fd, .06em 0 #b3d4fd, -.06em 0 #b3d4fd, .09em 0 #b3d4fd, -.09em 0 #b3d4fd, .12em 0 #b3d4fd, -.12em 0 #b3d4fd;
}

a::-moz-selection {
  background: #b3d4fd;
  text-shadow: .03em 0 #b3d4fd, -.03em 0 #b3d4fd, 0 .03em #b3d4fd, 0 -.03em #b3d4fd, .06em 0 #b3d4fd, -.06em 0 #b3d4fd, .09em 0 #b3d4fd, -.09em 0 #b3d4fd, .12em 0 #b3d4fd, -.12em 0 #b3d4fd;
}

h1 a {
  background-size: 0 0,0 0,0.07em 0.07em;
  background-position: 0% 90%, 100% 90%, 0% 98%;
}

h2 a, h3 a, h4 a, h5 a, h6 a {
  background-size: 0 0,0 0,0.07em 0.07em;
  background-position: 0% 90%, 100% 90%, 0% 97%;
}

a.tag {
  padding-left: 1.33em;
  margin-right: 1em;
  background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSIyMnB4IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyMyAyMiIgd2lkdGg9IjIzcHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c2tldGNoPSJodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2gvbnMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48dGl0bGUvPjxkZWZzPjxwYXRoIGQ9Ik0xMy4xMjgwNzM4LC0xLjg2ODA4NjcyIEw2LDQuMjk4NjQzMjcgTDYsMTkuNTY2ODc3NSBDNiwxOS44MzY4NjU4IDYuMjIzNjgyNiwyMC4wNTU3MzQ1IDYuNDk5MDc2ODUsMjAuMDU1NzM0NSBMMjAuNTAwOTIzMiwyMC4wNTU3MzQ1IEMyMC43NzY1NTU3LDIwLjA1NTczNDUgMjEsMTkuODMyOTg3MyAyMSwxOS41NjY4Nzc1IEwyMSw0LjI5ODY0MzI3IEwxMy44NzE5MjYyLC0xLjg2ODA4NjcyIEMxMy42NjY1MTcxLC0yLjA0NTc5MjkgMTMuMzI5MjYwNCwtMi4wNDIxMzk4MSAxMy4xMjgwNzM4LC0xLjg2ODA4NjcyIFogTTEzLjUsNy44MzM1MTIzMiBDMTQuNjA0NTY5Niw3LjgzMzUxMjMyIDE1LjUsNi45NTc5ODAzMiAxNS41LDUuODc3OTU2NzYgQzE1LjUsNC43OTc5MzMyMSAxNC42MDQ1Njk2LDMuOTIyNDAxMjEgMTMuNSwzLjkyMjQwMTIxIEMxMi4zOTU0MzA1LDMuOTIyNDAxMjEgMTEuNSw0Ljc5NzkzMzIxIDExLjUsNS44Nzc5NTY3NiBDMTEuNSw2Ljk1Nzk4MDMyIDEyLjM5NTQzMDUsNy44MzM1MTIzMiAxMy41LDcuODMzNTEyMzIgTDEzLjUsNy44MzM1MTIzMiBaIiBpZD0icGF0aC0xIi8+PC9kZWZzPjxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgaWQ9Im1pdSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiPjxnIGlkPSJjb21tb25fdGFnXzJfZ2VuZXJhbF9wcmljZV9nbHlwaCI+PHVzZSBmaWxsPSIjOTk5OTk5IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzLjUwMDAwMCwgOS4wMDAwMDApIHJvdGF0ZSg0NS4wMDAwMDApIHRyYW5zbGF0ZSgtMTMuNTAwMDAwLCAtOS4wMDAwMDApICIgeGxpbms6aHJlZj0iI3BhdGgtMSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI3BhdGgtMSIvPjwvZz48L2c+PC9zdmc+) left center/0.94em no-repeat;
}

/* RULE */

hr {width: 100%;margin: 24px auto -1px;border: none;border-bottom: 3px double #efefef; padding-bottom: 1.4em;text-shadow: none;box-shadow: none;}

/* CODE */

code {
  font-family: "IBM Plex Mono", Consolas, "Liberation Mono", Menlo, Courier, monospace;
  margin: 0;
  font-size: 85%;
  background: rgba(236, 236, 236);
  border-radius: 3px;
  line-height: 24px;
}

p code {
  line-height: 1em;
  padding: 4px;
  display: inline-block;
}
/*
p code:before,
p code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}*/

pre code {
  display: block;padding: 12px 18px;
  margin: -11px -16px -13px -18px;
  background-color: rgba(236, 236, 236)
}

/* TABLES */

table {
  display: block;
  width: auto;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
  border-collapse: collapse;
  border-spacing: 0;
  box-sizing: border-box;
  font-size: 15px;
  line-height: 24px;
}

tr {box-sizing: border-box;border-top: 1px solid #ccc;padding: 0}
th, td {box-sizing: border-box;border: 1px solid #ddd;padding: 5px 12px 6px}

/* LISTS */

ul, ol {
  margin-left: 0;
  padding-left: 0;
  list-style-position: outside;
  margin-bottom: 24px;
}

ul {list-style: circle;}

ul ul, ol ul, ol ol, ul ol {margin-left: 1.33em;margin-bottom: 0}

li {margin: 0}

/* IMAGES */

img {vertical-align: middle;max-width: 100%;height: auto;}

.image {
  position: relative;
  height: 0;
  padding: 0 0 35.504201681%;
  max-width: 100%;margin: 0 auto;display: block;
}

.image img {width: 100%}

.image_container {display: block}


.wide .image_container {margin: 0 auto}
.wide p {margin-top: 0}

/* VIDEOS & tweets */

iframe {width: 100%;}

/* Only apply vertical margin to direct
   descendants, prevents multi margins */
.entry > iframe {margin: 24px 0!important;}

/* TWEETS */

.entry .twitter-tweet {margin-left:-16px!important}

/* MATH */

.katex  {font-size: 1.05em;}



#logo {
  font-family: var(--main-font-family);
  font-weight: 300;
  letter-spacing: 0.8px;
  display:block;
  font-size: 22px;
  color: #222;
  position: relative;
  text-shadow: none;
  background-image: none;
}

#logo img {position: absolute;width: 48px;top: 0px;left: -62px;border-radius: 5px;border: 1px solid;}

#logo:hover {color: #555}
#logo img:hover {opacity: 0.8}

#logo img.rounded {width: 52px;border-radius: 50%;top: -2px;left: -64px}
#logo img:active {margin-top: 1px}

/* Nav links are underlined which affects their optical lineheight */
.nav {line-height: 20px;padding-bottom: 4px}
.nav a {margin-right: 6px;font-size: 14px;background: none;text-shadow: none;}

.nav a[href="/feed.rss"],
.nav a[href="/search"] {
  float: right;
  color: #000;
  font-weight: 500;
  font-size: 13px;
  padding-left: 1.25em;
  background: url('data:image/svg+xml;base64,PHN2ZyBpZD0iaWNvbi1icm9hZGNhc3QiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTIwIDEyMCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8Y2lyY2xlIGN4PSIxOC4zODUiIGN5PSIxMDEuNjE1IiByPSIxOC4zODUiLz4NCjxnPg0KCTxwYXRoIGQ9Ik0tMS4wMzEsNjFjMzIuNTMzLDAsNTksMjYuNDY4LDU5LDU5cy0yNi40NjcsNTktNTksNTlzLTU5LTI2LjQ2OC01OS01OVMtMzMuNTY0LDYxLTEuMDMxLDYxIE0tMS4wMzEsMzgNCgkJYy00NS4yODgsMC04MiwzNi43MTMtODIsODJzMzYuNzEyLDgyLDgyLDgyczgyLTM2LjcxMyw4Mi04MlM0NC4yNTcsMzgtMS4wMzEsMzhMLTEuMDMxLDM4eiIvPg0KPC9nPg0KPGc+DQoJPHBhdGggZD0iTTAuMTU0LDIzLjA0MWM1My4zNDksMCw5Ni43NSw0My40MDIsOTYuNzUsOTYuNzVzLTQzLjQwMiw5Ni43NS05Ni43NSw5Ni43NWMtNTMuMzQ4LDAtOTYuNzUtNDMuNDAyLTk2Ljc1LTk2Ljc1DQoJCVMtNTMuMTk0LDIzLjA0MSwwLjE1NCwyMy4wNDEgTTAuMTU0LDAuMDQxYy02Ni4xMzYsMC0xMTkuNzUsNTMuNjE1LTExOS43NSwxMTkuNzVzNTMuNjE0LDExOS43NSwxMTkuNzUsMTE5Ljc1DQoJCWM2Ni4xMzUsMCwxMTkuNzUtNTMuNjE1LDExOS43NS0xMTkuNzVTNjYuMjg5LDAuMDQxLDAuMTU0LDAuMDQxTDAuMTU0LDAuMDQxeiIvPg0KPC9nPg0KPC9zdmc+') no-repeat left center / 100%;
  background-size: 0.88em;
  opacity: 0.4;
  margin-left: 1em;
  background-position-y: 4px;
}

.nav a[href="/search"] {
  background-image: url(data:image/svg+xml;base64,PHN2ZyBpZD0iaWNvbi1zZWFyY2giIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgOCA4IiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxwYXRoIGlkPSJzZWFyY2giIGQ9Ik03Ljk5LDYuOTI4TDUuODQ3LDQuNzg0YzAuMjg5LTAuNDc2LDAuNDU4LTEuMDMzLDAuNDU4LTEuNjNDNi4zMDUsMS40MTIsNC44OTUsMCwzLjE1MiwwDQoJQzEuNDExLDAsMCwxLjQxMiwwLDMuMTU0YzAsMS43NDEsMS40MTIsMy4xNTEsMy4xNTMsMy4xNTFjMC41OTcsMCwxLjE1NC0wLjE2OSwxLjYzLTAuNDU4bDIuMTQ1LDIuMTQ2TDcuOTksNi45Mjh6IE0xLjIwMywzLjE1NA0KCWMwLjAwMi0xLjA3NywwLjg3NC0xLjk0OSwxLjk1MS0xLjk1MWMxLjA3NiwwLjAwMiwxLjk0OCwwLjg3NCwxLjk0OSwxLjk1MUM1LjEwMSw0LjIzLDQuMjI5LDUuMTAzLDMuMTUzLDUuMTAzDQoJQzIuMDc1LDUuMTAzLDEuMjA1LDQuMjMsMS4yMDMsMy4xNTR6Ii8+DQo8L3N2Zz4=);
  background-size: 0.94em;
}

a.feed:hover,
a.search:hover {opacity: 1}

input#search {
  font-size: 1.2em;
  padding: .5em 1em .5em 2.3em;
  background: url(data:image/svg+xml;base64,PHN2ZyBpZD0iaWNvbi1zZWFyY2giIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgOCA4IiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxwYXRoIGlkPSJzZWFyY2giIGQ9Ik03Ljk5LDYuOTI4TDUuODQ3LDQuNzg0YzAuMjg5LTAuNDc2LDAuNDU4LTEuMDMzLDAuNDU4LTEuNjNDNi4zMDUsMS40MTIsNC44OTUsMCwzLjE1MiwwDQoJQzEuNDExLDAsMCwxLjQxMiwwLDMuMTU0YzAsMS43NDEsMS40MTIsMy4xNTEsMy4xNTMsMy4xNTFjMC41OTcsMCwxLjE1NC0wLjE2OSwxLjYzLTAuNDU4bDIuMTQ1LDIuMTQ2TDcuOTksNi45Mjh6IE0xLjIwMywzLjE1NA0KCWMwLjAwMi0xLjA3NywwLjg3NC0xLjk0OSwxLjk1MS0xLjk1MWMxLjA3NiwwLjAwMiwxLjk0OCwwLjg3NCwxLjk0OSwxLjk1MUM1LjEwMSw0LjIzLDQuMjI5LDUuMTAzLDMuMTUzLDUuMTAzDQoJQzIuMDc1LDUuMTAzLDEuMjA1LDQuMjMsMS4yMDMsMy4xNTR6Ii8+DQo8L3N2Zz4=) 1em center/0.8em no-repeat;
  border-radius: 3em;
  width: 103.5%;
  box-sizing: border-box;
  margin: .33em .66em 2em -1em;
  border: 1px solid #A1ADB6;
  font-family: var(--main-font-family);
}

input#search:focus {
  outline: none;
  box-shadow: 0 0 5px rgba(100, 169, 226, 0.51);
  border: 1px solid #A1ADB6;
}

::-webkit-input-placeholder {
   color: #A4A9B0;
}

:-moz-placeholder { /* Firefox 18- */
   color: #A4A9B0;
}

::-moz-placeholder {  /* Firefox 19+ */
   color: #A4A9B0;
}

:-ms-input-placeholder {
   color: #A4A9B0;
}

.date {margin-top: 1rem;background: none;text-shadow: none;}
.date:empty {display: none;}

/* Reset the spacing when date is not followed by an h1 tag */
.entry .date + p,
.entry .date + ul,
.entry .date + ol {position: relative;top: 9px;padding-bottom: 9px}

.entry .date + .wide {position: relative;top: 2.66em;padding-bottom: 2.66em}
.entry .date + .wide.right {position: relative;top: 0.66em;padding-bottom: 0.66em}
.entry .date + h2,
.entry .date + h3,
.entry .date + h4,
.entry .date + h5,
.entry .date + h6
 {position: relative;top: 9px;}

/* Pagination */
.pagination {
  text-align: center;
  margin: 72px 0 144px;
  font-size: 14px;color: #999
}

.pagination a {margin: 0 1em;background: none}

.previousEntry,
.nextEntry {
  text-decoration: none;
  background: none;
  text-shadow: none;
  font-size: 0.88em;
  line-height: 1.33em;
  width: 48%;
  margin: 1em 0 6em 2%;
  color: #000;
  display: block;
  float: left;
}

.previousEntry {margin: 1em 2% 6em 0;}

.adjacent a h5 {margin-bottom: 3px;color: #000}
.adjacent a .summary {color: #6B6B6B;font-size: 13px;line-height: 17px;}

.previousEntry .title,
.nextEntry .title {
  display: block;
  font-size: 1.156em;
  font-family: var(--main-font-family);
  line-height: 20px;
  margin-bottom: 3px
}

@media screen and (max-width: 976px) {

  .main {max-width: 600px;min-width: 0}

  .entry .margin {position: relative;top: auto;left: auto;right: auto;bottom: auto;}

  .entry .margin.right {
    float: right;
  }

  .entry .margin.left {
    text-align: left;
    display: block;
    float: left;
  }

  .entry .date {width: 100%;}

  .entry .margin .caption,
  .entry .margin p {margin-bottom: 6px;text-align: left;}

  .wide, .wide.left, .wide.right {width: 100%;margin: 0}
  .wide.left .caption {margin-left: 0}

  .date {position: absolute;top: -24px;left: 0;text-align: left;margin: 0}
}

@media screen and (max-width: 730px) {
  /*  .nav, #logo {margin-left: 60px} */
  ul, li {margin-left: 24px}
  ul ul, ol ul, ol ol, ul ol {margin-left: 0}
  .nav .right {clear: both;float: none;margin-top: 3px}
  a.search {margin-left: 0}
}

@media screen and (max-width: 400px) {
  .entry .twitter-tweet {margin-left: 0!important}
  .header {margin: 9px auto -12px}
}

/* The theme used by the syntax highlighting app */
.hljs {display: block;overflow-x: auto;}
.hljs-comment, .hljs-quote, .hljs-variable {color: #008000;}
.hljs-keyword, .hljs-selector-tag, .hljs-built_in, .hljs-name, .hljs-tag {color: #00f;}
.hljs-string, .hljs-title, .hljs-section, .hljs-attribute, .hljs-literal, .hljs-template-tag, .hljs-template-variable, .hljs-type, .hljs-addition {color: #a31515;}
.hljs-deletion, .hljs-selector-attr, .hljs-selector-pseudo, .hljs-meta {color: #2b91af;}
.hljs-doctag {color: #808080;}
.hljs-attr {color: #f00;}
.hljs-symbol, .hljs-bullet, .hljs-link {color: #00b0e8;}
.hljs-emphasis {font-style: italic;}
.hljs-strong {font-weight: bold;}
    </style>
</head>  <body>
<div class="container header">
  <div class="main">
    <!--
    <a id="logo" href="/">
      Atif Afzal
    </a>
	-->
    <div class="nav">
      <a href="&#x2F;" title="Home">Home</a>
      <a href="&#x2F;archives" title="Archives">Archives</a>
      <a href="&#x2F;search" title="Search">Search</a>
      <a href="&#x2F;feed.rss" title="Feed">Feed</a>
      <a href="&#x2F;about" title="About">About</a>
    </div>
  </div>
</div>    <div class="container">
      <div class="main">
        <div class="entry">
          <a class="small date left margin" href="&#x2F;javascript-event-loop-much-more-than-you-wanted-to-know">March 8, 2023</a>

          <h1 id="javascript-event-loop-much-more-than-you-wanted-to-know">JavaScript Event Loop: Much more than you wanted to know</h1>
<p><em>Note: We’ll cover the event loop in context of browsers and not other runtimes like Node.js</em></p>
<p>The event loop is a mechanism/algorithm/set of rules that specifies how asynchronous code is handled in JavaScript. This is important because JavaScript is single threaded, it can run one thing at a time. When the main thread is busy, we queue the pending events and these are run later when the main thread is available.</p>
<p>When we say JavaScript is single threaded, we are talking about the main UI thread where everything related to the UI is run. This includes user interaction handling, rendering, user scripts etc. The browser might be having more threads that it uses internally but our code is run in this main UI thread. There is <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank">Web Workers API</a> which can spawn new threads and our code can run in it, but it can’t interact with the UI directly.</p>
<p>Historically, event loop was not part of the JavaScript specification, the host environments were free to implement it without any standard. The event loop standard was first specified in the <a href="https://262.ecma-international.org/6.0/#sec-jobs-and-job-queues" target="_blank">ES6 specification</a>. Before node 11 was released in 2019, the event loop behavior was different in node.js and the browsers. <a href="#footnote-1NHT" class="footnote-ref" id="ref-1NHT" role="doc-noteref"><sup>1</sup></a></p>
<p>When we try to run any JavaScript code, they might come to the event loop in the form of different type of tasks:</p>
<ul>
<li>macro task</li>
<li>micro task</li>
<li>requestAnimationFrame task</li>
<li>nano task (this is only available in node.js, we won’t talk about this, we are focused on browsers)</li>
</ul>
<h2 id="macro-task">Macro task</h2>
<p>This is the most common type of task in the event loop. This includes these but is not limited to:</p>
<ul>
<li>code running from a script tag</li>
<li>callback in a timer</li>
<li>callback run when a network request is finished using <code>XMLHttpRequest</code></li>
<li>collection of multiple handler callbacks in response to an event</li>
</ul>
<h3 id="timer-macro-task">Timer macro task</h3>
<p>Doing <code>setTimeout(cb, 0)</code> is the most common form of queueing a macro task in the macro task queue.</p>
<pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout&#x27;</span>);
}, <span class="hljs-number">0</span>);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script&#x27;</span>);</code></pre>
<p>Firstly, this code itself is running as a macro task. To execute this code in the browser, we have to use a <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script" target="_blank">script</a> which adds this code as a macro task in the macro task queue. The event loop then picks this up from the macro task queue.</p>
<p>The <code>setTimeout</code> function is called, the timer is started by the hosting environment. The timer is running in parallel to our main thread, when the timer will expire in the future it adds the callback with <code>console.log('timeout')</code> to the macro task queue.</p>
<p>Now back to the present, while the timer has started running in parallel, the main thread has other code to run like the <code>console.log('script')</code>. In JavaScript, a code once started is always <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#run-to-completion" target="_blank">run to completion</a> before anything else can run, i.e. it cannot be interrupted in between for other task. The new task is instead queued in a task queue when it is ready to run on the main thread and runs when its turn comes.</p>
<p>When a macro task finishes, a task from the macro task queue is picked to run again to completion. If there were multiple macro tasks which were enqueued while the main thread was busy, we’ll get the first macro task and others will wait in the queue.</p>
<p>The pseudocode for the event loop with macro task looks like this:</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eventLoop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> macroTaskQueue = [];

  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">const</span> macroTask = macroTaskQueue.shift();
    runToCompletion(macroTask);
  }
}</code></pre>
<h4 id="quirk-in-using-settimeout-for-queueing-macro-task">Quirk in using setTimeout for queueing macro task</h4>
<p>A small detour before moving back to event loop. <code>setTimeout</code> has a strange behavior which is even listed in the HTML standard.</p>
<blockquote>
<p>Timers can be nested; after five such nested timers, however, the interval is forced to be at least four milliseconds. – <a href="https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers" target="_blank">HTML Standard</a></p>
</blockquote>
<p>Code snippet creating nested <code>setTimeout</code> calls with depth = 10.</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> depth = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> previousTime = performance.now();
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recurse</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (depth &gt; <span class="hljs-number">10</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">const</span> nowTime = performance.now();
  <span class="hljs-built_in">console</span>.log({ depth, <span class="hljs-attr">time</span>: nowTime - previousTime });
  previousTime = nowTime;
  depth += <span class="hljs-number">1</span>;
  <span class="hljs-built_in">setTimeout</span>(recurse, <span class="hljs-number">0</span>);
}

<span class="hljs-built_in">setTimeout</span>(recurse, <span class="hljs-number">0</span>);</code></pre>
<p>The output of above snippet in Chrome <code>Version 110.0.5481.177 (Official Build) (arm64)</code> is</p>
<pre><code>{depth: 1, time: 0.7999999970197678}
{depth: 2, time: 0.4000000059604645}
{depth: 3, time: 0.09999999403953552}
{depth: 4, time: 0.10000000149011612}
{depth: 5, time: 4.700000002980232}
{depth: 6, time: 4.799999997019768}
{depth: 7, time: 4.200000002980232}
{depth: 8, time: 4.799999997019768}
{depth: 9, time: 4.800000004470348}
{depth: 10, time: 5.799999997019768}</code></pre>
<p>After 5 recursive nested calls, <code>setTimeout(cb, 0)</code> takes at least 4ms to put the callback to the macro task queue.</p>
<p>Because of this, <code>setTimeout</code> is not the most reliable way to queue a macro task to the macro task queue.</p>
<p>A better way is to use <a href="https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel" target="_blank">MessageChannel</a> to enqueue a macro task. <a href="#footnote-2NHT" class="footnote-ref" id="ref-2NHT" role="doc-noteref"><sup>2</sup></a></p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queueMacroTask</span>(<span class="hljs-params">cb</span>) </span>{
  <span class="hljs-keyword">const</span> mc = <span class="hljs-keyword">new</span> MessageChannel();
  mc.port1.postMessage (<span class="hljs-literal">null</span>);
  mc.port2.addEventListener(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">() =&gt;</span> {
    cb();
  }, {<span class="hljs-attr">once</span>: <span class="hljs-literal">true</span>});
  mc.port2.start();
}</code></pre>
<p>Running the same code which we ran before with our <code>queueMacroTask</code>:</p>
<pre><code class="hljs js"><span class="hljs-keyword">let</span> depth = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> previousTime = performance.now();
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recurse</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (depth &gt; <span class="hljs-number">10</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">const</span> nowTime = performance.now();
  <span class="hljs-built_in">console</span>.log({ depth, <span class="hljs-attr">time</span>: nowTime - previousTime });
  previousTime = nowTime;
  depth += <span class="hljs-number">1</span>;
  queueMacroTask(recurse);
}

queueMacroTask(recurse);</code></pre>
<p>The result is:</p>
<pre><code>{depth: 1, time: 0.4000000059604645}
{depth: 2, time: 0.5}
{depth: 3, time: 0.09999999403953552}
{depth: 4, time: 0.10000000149011612}
{depth: 5, time: 0.10000000149011612}
{depth: 6, time: 0.20000000298023224}
{depth: 7, time: 0.09999999403953552}
{depth: 8, time: 0.20000000298023224}
{depth: 9, time: 0.20000000298023224}
{depth: 10, time: 0.19999999552965164}</code></pre>
<p>This is better than <code>setTimeout</code>, it doesn’t have the 4ms quirk.</p>
<p>Now let’s go back to the event loop.</p>
<h3 id="event-listener-macro-task">Event listener macro task</h3>
<p>This covers the case of having multiple callbacks in a single macro task.</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> outer = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;outer&#x27;</span>);
<span class="hljs-keyword">const</span> inner = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;inner&#x27;</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onClick</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;click event&quot;</span>, <span class="hljs-built_in">this</span>.id);
}

inner.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, onClick);
outer.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, onClick);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script&#x27;</span>);</code></pre>
<p>In this snippet we have two divs - <code>inner</code> div inside the <code>outer</code> div. Clicking on the text <code>Click me</code> enqueues a task which consists of two callbacks one for the <code>inner</code> div click event handler and other for the <code>outer</code> div click event handler because of <a href="https://javascript.info/bubbling-and-capturing#bubbling" target="_blank">event bubbling</a>.</p>
<p>This is important for future sections - <strong>a single macro task can consist of multiple callbacks</strong>. DOM has provided these multiple callbacks to this single macro task.</p>
<p>And this was a basic example, doing small DOM manipulation can cause a lot of callbacks to be triggered in production code.</p>
<p>Now, let’s write the new updated event loop pseudocode keeping in mind that a single macro task can consist of multiple callbacks.</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eventLoop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> macroTaskQueue = [];

  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">const</span> macroTaskCallbacks = macroTaskQueue.shift();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; macrotaskCallbacks.length; ++i) {
      <span class="hljs-keyword">const</span> macroTaskCallback = macroTaskCallbacks[i];
      runToCompletion(macroTaskCallback);
    }
  }
}</code></pre>
<p>There’s a special case<a href="#footnote-3NHT" class="footnote-ref" id="ref-3NHT" role="doc-noteref"><sup>3</sup></a> that we should discuss. The snippet is similar to the previous one but here we call <code>click</code> in the program itself instead of clicking it manually by ourselves in real life.</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> outer = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;outer&#x27;</span>);
<span class="hljs-keyword">const</span> inner = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;inner&#x27;</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onClick</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;click event&quot;</span>, <span class="hljs-built_in">this</span>.id);
}

inner.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, onClick);
outer.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, onClick);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script&#x27;</span>);

inner.click();</code></pre>
<p>When we programmatically call the <code>click</code> function, then there’s no new macro task which will be queued to the macro task queue. We’ll still be continuing the main <code>script</code> level macro task when running both <code>onClick</code> functions later on.</p>
<p>It’ll be similar to this pseudo code:</p>
<pre><code>inner.click = (e) =&gt; {
  onClick.call(inner, e);
  onClick.call(outer, e);
};</code></pre>
<p>which keeps the <code>onClick</code> handlers in the same function call and not create new macro task callbacks.</p>
<p>Although, this new snippet outputs in the same sequence but will have different behavior when mixed with micro tasks.</p>
<h2 id="micro-tasks">Micro tasks</h2>
<p>Micro tasks were created to be used for <a href="https://javascript.info/mutation-observer" target="_blank">Mutation observer</a>.</p>
<p>JavaScript Promises use micro tasks. The Promise implementation was first done in the user land, there were a lot of libraries implementing Promise before <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank">native Promise</a> was available in the browsers. Library authors were in competition to create fast Promise library, so they started using micro tasks for implementing Promise.<a href="#footnote-4NHT" class="footnote-ref" id="ref-4NHT" role="doc-noteref"><sup>4</sup></a></p>
<p>Micro tasks are run when the current task callback has finished running to completion (the call stack is empty).</p>
<p>When the micro tasks start running, they exhaust the complete micro task queue. If in between a micro task, new micro tasks are queued then they are run till the micro task queue is empty.</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addMicroTask</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> {
    addMicroTask();
  });
}

addMicroTask();</code></pre>
<p>The above code will block the main thread because the micro task will keep on increasing and the micro task queue will never end.</p>
<p>Let’s check out a mix of macro task and micro task:</p>
<pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout&#x27;</span>);
}, <span class="hljs-number">0</span>);

<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise&#x27;</span>);
});

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script&#x27;</span>);</code></pre>
<p>The current macro task running is the main script which has the statement <code>console.log('script')</code>. When the first statement with <code>setTimeout</code> runs, it starts off the timer, which will add the callback to the macro task queue after 0 ms.</p>
<p>The <code>Promise.resolve()</code> statement resolves this promise immediately and adds the <code>console.log('promise')</code> callback to the micro task queue.</p>
<p>The statement with <code>console.log('script')</code> runs immediately and prints <code>'script'</code>. This ends the current <code>script</code> macro task. We then exhaust the micro task queue which prints <code>'promise'</code>, and then continue the event loop and get the next macro task which prints <code>'timeout'</code>.</p>
<p>Updated event loop pseudo code:</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eventLoop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> macroTaskQueue = [];
  <span class="hljs-keyword">const</span> microTaskQueue = [];

  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">const</span> macroTaskCallbacks = macroTaskQueue.shift();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; macrotaskCallbacks.length; ++i) {
      <span class="hljs-keyword">const</span> macroTaskCallback = macroTaskCallbacks[i];
      runToCompletion(macroTaskCallback);
      <span class="hljs-keyword">while</span> (microTaskQueue.length !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">const</span> microTask = microTaskQueue.shift();
        runToCompletion(microTask);
      }
    }
  }
}</code></pre>
<p>The important thing to note - <strong>the micro task exhaustion starts after each callback of the macro task is finished</strong>. Even if a macro task has multiple callbacks, then the micro task queue exhaustion starts with - when the first callback ends. It won’t wait for all the callbacks of the current macro task to finish.</p>
<p>Refactoring the code by moving micro task exhaustion code to a function:</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eventLoop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> macroTaskQueue = [];
  <span class="hljs-keyword">const</span> microTaskQueue = [];

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exhaustMicroTaskQueue</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">while</span> (microTaskQueue.length !== <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> microTask = microTaskQueue.shift();
      runToCompletion(microTask);
    }
  }

  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">const</span> macroTaskCallbacks = macroTaskQueue.shift();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; macroTaskCallbacks.length; ++i) {
      <span class="hljs-keyword">const</span> macroTaskCallback = macroTaskCallbacks[i];
      runToCompletion(macroTaskCallback);
      exhaustMicroTaskQueue()
    }
  }
}</code></pre>
<p>Unlike macro tasks which do not provide a direct way to enqueue a task to the macro task queue, micro tasks have a function <a href="https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask" target="_blank">queueMicroTask</a> which can be used to directly enqueue a callback to the micro task queue.</p>
<p>Now, back to the special case that we talked about earlier in macro task section. Let’s add a Promise to mix macro and micro tasks:</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> outer = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;outer&#x27;</span>);
<span class="hljs-keyword">const</span> inner = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;inner&#x27;</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onClick</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;click event&quot;</span>, <span class="hljs-built_in">this</span>.id);
  
  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;resolved&quot;</span>, <span class="hljs-built_in">this</span>.id);
  });
}

inner.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, onClick);
outer.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, onClick);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script&#x27;</span>);

inner.click();</code></pre>
<p>The result of this code is:</p>
<pre><code>script
click event inner
click event outer
resolved inner
resolver outer</code></pre>
<p>Because there was no new macro task, the script macro task continued and the <code>onClick</code> functions were called on the top of the running stack. Because the original script macro task callback was not finished, the micro task exhaustion does not start and we see the <code>resolved x</code> logs at the end when the original script macro task finishes after both <code>onClick</code> handlers are called.</p>
<p>Removing <code>inner.click</code> and manually clicking the inner div instead generates this output:</p>
<pre><code>script
click event inner
resolved inner
click event outer
resolved outer</code></pre>
<p>After logging <code>script</code>, the main script macro task ends. The new macro task has 2 callbacks: first for inner <code>onClick</code>, second for outer <code>onClick</code>. Now, at the end of the first callback we exhaust the micro task queue. And then after running the second callback, we exhaust the micro task queue again.</p>
<h2 id="rendering">Rendering</h2>
<p>Rendering is a part of the event loop <a href="#footnote-5NHT" class="footnote-ref" id="ref-5NHT" role="doc-noteref"><sup>5</sup></a>. Rendering happens at the end of the current event loop iteration (each event loop iteration is also known as a tick of the event loop). And it happens only when required i.e. when it is time to render a new frame - after an interval of ~16 ms for a 60 hertz display. Although, <strong>the browser might have to skip rendering of some frames if the phases before rendering took a lot of time</strong>.</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eventLoop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// ...</span>

  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">const</span> macroTaskCallbacks = macroTaskQueue.shift();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; macroTaskCallbacks.length; ++i) {
      <span class="hljs-keyword">const</span> macroTaskCallback = macroTaskCallbacks[i];
      runToCompletion(macroTaskCallback);
      exhaustMicroTaskQueue()
    }

    <span class="hljs-keyword">if</span> (isItTimeForNextFrameRender()) {
      render();
    }
  }
}</code></pre>
<p>If we want to run something just before the rendering of a frame happens - we can use <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank">requestAnimationFrame</a>. If we call <code>requestAnimationFrame</code> multiple times before the frame is rendered then all the callbacks passed are enqueued in a queue and these all are run before the frame renders.</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eventLoop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">const</span> rAFQueue = [];
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-comment">// ...</span>
    
    <span class="hljs-keyword">if</span> (isItTimeForNextFrameRender()) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; rAFQueue.length; ++i) {
        <span class="hljs-keyword">const</span> rAFTask = rAFQueue[i];
        runToCompletion(rAFTask);
      }

      render();
    }
  }
}</code></pre>
<p>The important thing to note is - <strong>the new rAF callbacks queued are not run in this tick</strong> (because we only looped over the current tasks and are not using the new ones). The new ones are queued for the next time when we need to render the next frame.</p>
<p>Let’s take a look at this set of code snippets:</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onClick</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">document</span>.body.style.backgroundColor = <span class="hljs-string">&quot;red&quot;</span>;
  <span class="hljs-built_in">document</span>.body.style.backgroundColor = <span class="hljs-string">&quot;blue&quot;</span>;
}

<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;button&#x27;</span>)
  .addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, onClick);</code></pre>
<p>After clicking, what will happen? Will we see both red and blue background color in sequence or just the blue background? We can now answer this question using the event loop.</p>
<p>The current code is running as a macro task via a script tag. Now, on click - a new macro task is pushed which is the onClick function. This onClick function runs to completion and only then we go to the rendering phase. In the end the last value of backgroundColor - blue is used to render the page.</p>
<p>What if we wanted to first render the page with red color and then with blue in the next frame. Would using a <code>requestAnimationFrame</code> help. Will this work?:</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onClick</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">document</span>.body.style.backgroundColor = <span class="hljs-string">&quot;red&quot;</span>;
  requestAnimationFrame(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">document</span>.body.style.backgroundColor = <span class="hljs-string">&quot;blue&quot;</span>;
  });
}</code></pre>
<p>This still won’t work because we know that the <code>requestAnimationFrame</code> callbacks are run before rendering. The render phase will get the backgroundColor = blue.</p>
<p>We can use 2 nested <code>requestAnimationFrame</code> callbacks to solve this. Now just before rendering the second frame we’ll set the backgroundColor to blue. Which creates the effect that we want.</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onClick</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">document</span>.body.style.backgroundColor = <span class="hljs-string">&quot;red&quot;</span>;
  requestAnimationFrame(<span class="hljs-function">() =&gt;</span> {
    requestAnimationFrame(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-built_in">document</span>.body.style.backgroundColor = <span class="hljs-string">&quot;blue&quot;</span>;
    });
  });
}</code></pre>
<p>Next important thing is - <strong>micro task can also run between these <code>requestAnimationFrame</code> callbacks for the current frame similar to multiple callbacks in a macro task</strong>.</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eventLoop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">const</span> rAFQueue = [];
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-comment">// ...</span>
    
    <span class="hljs-keyword">if</span> (isItTimeForNextFrameRender()) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; rAFQueue.length; ++i) {
        <span class="hljs-keyword">const</span> rAFTask = rAFQueue[i];
        runToCompletion(rAFTask);
        exhaustMicroTaskQueue();
      }

      render();
    }
  }
}</code></pre>
<h2 id="final-event-loop-code">Final event loop code</h2>
<p>This is the final event loop code which can be used to reason about any code that you see in your JavaScript code in the browser environments.</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eventLoop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> macroTaskQueue = [];
  <span class="hljs-keyword">const</span> microTaskQueue = [];
  <span class="hljs-keyword">const</span> rAFQueue = [];
  
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exhaustMicroTaskQueue</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">while</span> (microTaskQueue.length !== <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> microTask = microTaskQueue.shift();
      runToCompletion(microTask);
    }
  }
  
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">const</span> macroTaskCallbacks = macroTaskQueue.shift();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; macroTaskCallbacks.length; ++i) {
      <span class="hljs-keyword">const</span> macroTaskCallback = macroTaskCallbacks[i];
      runToCompletion(macroTaskCallback);
      exhaustMicroTaskQueue();
    }

    <span class="hljs-keyword">if</span> (isItTimeForNextFrameRender()) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; rAFQueue.length; ++i) {
        <span class="hljs-keyword">const</span> rAFTask = rAFQueue[i];
        runToCompletion(rAFTask);
        exhaustMicroTaskQueue();
      }

      render();
    }
  }
}</code></pre>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="footnote-1NHT" role="doc-endnote"><p><a href="https://blog.insiderattack.net/new-changes-to-timers-and-microtasks-from-node-v11-0-0-and-above-68d112743eb3" class="uri" target="_blank">https://blog.insiderattack.net/new-changes-to-timers-and-microtasks-from-node-v11-0-0-and-above-68d112743eb3</a><a href="#ref-1NHT" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="footnote-2NHT" role="doc-endnote"><p><a href="https://youtu.be/8eHInw9_U8k?t=495" class="uri" target="_blank">https://youtu.be/8eHInw9_U8k?t=495</a><a href="#ref-2NHT" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="footnote-3NHT" role="doc-endnote"><p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/#level-1-bosss-angry-older-brother" class="uri" target="_blank">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/#level-1-bosss-angry-older-brother</a><a href="#ref-3NHT" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="footnote-4NHT" role="doc-endnote"><p><a href="https://stackoverflow.com/questions/66190571/what-was-the-motivation-for-introducing-a-separate-microtask-queue-which-the-eve#answer-66386291" class="uri" target="_blank">https://stackoverflow.com/questions/66190571/what-was-the-motivation-for-introducing-a-separate-microtask-queue-which-the-eve#answer-66386291</a><a href="#ref-4NHT" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="footnote-5NHT" role="doc-endnote"><p><a href="https://html.spec.whatwg.org/multipage/webappapis.html#update-the-rendering" class="uri" target="_blank">https://html.spec.whatwg.org/multipage/webappapis.html#update-the-rendering</a><a href="#ref-5NHT" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>


          <div class="clear"></div>
          <div class="clear"></div>

        </div>
<!-- <script src="/script.js?cache=1683965176973&amp;extension=.js" type="text/javascript"></script> -->
      </div>
    </div>
  </body>
</html>
